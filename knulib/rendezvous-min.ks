{function Z{parameter value.if value>360 return mod(value,360).if value<0 until value>=0 set value to value+360. return value.}function Y{parameter orbitable.return Z(orbitable:OBT:LAN+orbitable:OBT:argumentOfPeriapsis+orbitable:OBT:trueAnomaly).}export(Lex("version","1.2.0","U0",Y@,"transferAnomalyCirc",{parameter A,B is TARGET,D is SHIP,F IS BODY. return Z(180+A-CONSTANT:PI*SQRT(((D:OBT:semiMajorAxis+B:OBT:semiMajorAxis)/2)^3/F:MU)*360/B:OBT:period).},"transferEtaCirc",{parameter A,B is TARGET,D is SHIP. return Z(Z(Y(B)-Y(D))-A)/abs(360/B:OBT:period-360/D:OBT:period).},"relativeNodes",{parameter A is TARGET,B is SHIP. local D is B:position-BODY:position. local F is VCRS(D,B:velocity:orbit).local H is VCRS(F,VCRS(A:position-BODY:position,A:velocity:orbit)).local J is VANG(H,D).local K is VANG(-H,D).local L is Lex().if VANG(D,VCRS(F,H))>90{set K to K+J*2.set L["next"]to "AN".set L["other"]to "DN".}else{set J to J+K*2.set L["next"]to "DN".set L["other"]to "AN".}local M is 360+B:OBT:trueAnomaly. set L["AN"]to mod(M+J,360).set L["DN"]to mod(M+K,360).return L.},"relativeInclination",{parameter A is TARGET,B is SHIP. return VANG(VCRS(B:position-BODY:position,B:velocity:orbit),VCRS(A:position-BODY:position,A:velocity:orbit)).},"inclinedLaunchWindow",{parameter A,B is 3.local D is 0.local F is 90.local H is BODY:rotationAngle+SHIP:geoPosition:LNG. local J is A:OBT:LAN. local K is J + 180.if J<H set J to J+360.if K<H set K to K+360.if J<K{set D to J-H. set F to 90-A:OBT:inclination.}else{set D to K-H. set F to 90+A:OBT:inclination.}local L is 360/BODY:rotationPeriod. set D to D-B/2*L. return List(D/L+TIME:seconds,F).})).}